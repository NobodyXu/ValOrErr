.TH "ValOrErr_t< variant, in_place_type_t, Ret, Ts >" 3 "Sat Nov 21 2020" "ValOrErr" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ValOrErr_t< variant, in_place_type_t, Ret, Ts >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ValOrErr\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBValOrErr_t\fP ()=default"
.br
.ti -1c
.RI "template<class T , class decay_T  = typename std::decay<T>::type, class  = typename std::enable_if<holds_type<decay_T>() &&                                               ValOrErrImpl::is_constructible<decay_T, T>()>::type> \fBValOrErr_t\fP (T &&obj) noexcept(ValOrErrImpl::is_nothrow_constructible< decay_T, T >())"
.br
.ti -1c
.RI "template<class T , class \&.\&.\&. Args, class  = typename std::enable_if<holds_type<T>() &&                                               std::is_constructible<T, Args\&.\&.\&.>::value>::type> \fBValOrErr_t\fP (in_place_type_t< T > type, Args &&\&.\&.\&.args) noexcept(std::is_nothrow_constructible< T, Args\&.\&.\&. >::value)"
.br
.ti -1c
.RI "template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps> \fBValOrErr_t\fP (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > &r)"
.br
.ti -1c
.RI "template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps, class  = typename std::enable_if<!std::is_same<                                          ValOrErr_t,                                           ValOrErr_t<variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&.>                                      >::value>::type> \fBValOrErr_t\fP (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > &&r)"
.br
.ti -1c
.RI "\fBValOrErr_t\fP (const \fBValOrErr_t\fP &)=delete"
.br
.ti -1c
.RI "\fBValOrErr_t\fP (\fBValOrErr_t\fP &&other) noexcept(std::is_nothrow_move_constructible< variant_t >::value)"
.br
.ti -1c
.RI "template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps> \fBValOrErr_t\fP & \fBoperator=\fP (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > &r)"
.br
.ti -1c
.RI "template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps> \fBValOrErr_t\fP & \fBoperator=\fP (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > &&r)"
.br
.ti -1c
.RI "template<class T , class \&.\&.\&. Args, class  = typename std::enable_if<holds_exp<T>() && std::is_constructible<T, Args\&.\&.\&.>::value>::type> void \fBset_exception\fP (Args &&\&.\&.\&.args)"
.br
.ti -1c
.RI "template<class \&.\&.\&. Args, class  = typename std::enable_if<std::is_constructible<Ret, Args\&.\&.\&.>::value>::type> void \fBset_return_value\fP (Args &&\&.\&.\&.args)"
.br
.ti -1c
.RI "bool \fBhas_exception_set\fP () const noexcept"
.br
.ti -1c
.RI "bool \fBhas_exception_handled\fP () const noexcept"
.br
.ti -1c
.RI "template<class T > bool \fBhas_exception_type\fP () const noexcept"
.br
.ti -1c
.RI "template<class F > auto \fBCatch\fP (F &&f) \-> \fBValOrErr_t\fP &"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> auto & \fBget_return_value\fP () &"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> auto & \fBget_return_value\fP () const &"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> auto && \fBget_return_value\fP () &&"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> auto && \fBget_return_value\fP () const &&"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> \fBoperator T&\fP () &"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> \fBoperator const T &\fP () const &"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> \fBoperator T&&\fP () &&"
.br
.ti -1c
.RI "template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> \fBoperator const T &&\fP () const &&"
.br
.ti -1c
.RI "\fB~ValOrErr_t\fP () noexcept(false)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret, class \&.\&.\&. Ts>
.br
class ValOrErr_t< variant, in_place_type_t, Ret, Ts >"
ValOrErr forces the exception returned to be handled, otherwise it would be thrown in destructor\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fIvariant\fP must has
.IP "\(bu" 2
API identical to std::variant, including ADL-lookupable visit,
.IP "\(bu" 2
override ret_exception::impl::holds_alternative_t for variant and provides variant_non_member_t<variant>::holds_alternative, which should has the same API as std::holds_alternative\&.
.IP "\(bu" 2
override std::get for you type 
.PP
.br
\fITs\&.\&.\&.\fP must not be void or the same type as Ret or has duplicated types\&. 
.RE
.PP

.PP
Definition at line 19 of file ValOrErr\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::\fBValOrErr_t\fP ()\fC [default]\fP"
If Ret != void, default initializae Ret; Else, construct empty ValOrErr that contain no exception\&. 
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T , class decay_T  = typename std::decay<T>::type, class  = typename std::enable_if<holds_type<decay_T>() &&                                               ValOrErrImpl::is_constructible<decay_T, T>()>::type> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::\fBValOrErr_t\fP (T && obj)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP must be in Ts\&.\&.\&. Copy construct or move construct type T\&. 
.RE
.PP

.PP
Definition at line 232 of file ValOrErr\&.hpp\&.
.PP
.nf
233                                                                     :
234             has_exception{!std::is_same<decay_T, Ret>::value},
235             v{in_place_type_t<decay_T>{}, std::forward<T>(obj)}
236     {}
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T , class \&.\&.\&. Args, class  = typename std::enable_if<holds_type<T>() &&                                               std::is_constructible<T, Args\&.\&.\&.>::value>::type> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::\fBValOrErr_t\fP (in_place_type_t< T > type, Args &&\&.\&.\&. args)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP must be in Ts\&.\&.\&. In place construct type T 
.RE
.PP

.PP
Definition at line 245 of file ValOrErr\&.hpp\&.
.PP
.nf
246                                                               :
247             has_exception{!std::is_same<T, Ret>::value}, 
248             v{type, std::forward<Args>(args)\&.\&.\&.}
249     {}
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::\fBValOrErr_t\fP (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > & r)\fC [inline]\fP"
This ctor would only cp/mv the exceptions of type Type held by r only if Type is also in Ts\&.\&.\&.
.PP
Return value is a bit special here: If return value from r is convertible to Ret, then it will be copied if r contains return value\&. 
.PP
Definition at line 260 of file ValOrErr\&.hpp\&.
.PP
.nf
260                                                                          :
261             v{in_place_type_t<monostate>{}}
262     {
263         from_other(r);
264     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps, class  = typename std::enable_if<!std::is_same<                                          ValOrErr_t,                                           ValOrErr_t<variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&.>                                      >::value>::type> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::\fBValOrErr_t\fP (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > && r)\fC [inline]\fP"
This ctor would only cp/mv the exceptions of type Type held by r only if Type is also in Ts\&.\&.\&.
.PP
Return value is a bit special here: If return value from r is convertible to Ret, then it will be moved if r contains return value\&. 
.PP
Definition at line 280 of file ValOrErr\&.hpp\&.
.PP
.nf
280                                                                           :
281             v{in_place_type_t<monostate>{}}
282     {
283         from_other(std::move(r));
284     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::\fBValOrErr_t\fP (\fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts > && other)\fC [inline]\fP, \fC [noexcept]\fP"
move constructor is required as NRVO isn't guaranteed to happen\&. 
.PP
Definition at line 291 of file ValOrErr\&.hpp\&.
.PP
.nf
292                                                                   :
293             is_exception_handled{other\&.is_exception_handled},
294             has_exception{other\&.has_exception},
295             v{std::move(other\&.v)}
296     {
297         other\&.has_exception = 0;
298         other\&.v\&.template emplace<monostate>();
299     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::~\fBValOrErr_t\fP ()\fC [inline]\fP, \fC [noexcept]\fP"
If an exception is contained in this object and it is not handled when dtor is called, this would cause the program to terminate\&. 
.PP
Definition at line 508 of file ValOrErr\&.hpp\&.
.PP
.nf
509     {
510         throw_if_hold_exp();
511     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps> \fBValOrErr_t\fP& \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::operator= (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > & r)\fC [inline]\fP"
Would only cp/mv the exceptions of type Type held by r only if Type is also in Ts\&.\&.\&.
.PP
Return value is a bit special here: If return value from r is convertible to Ret, then it will be copied if r contains return value\&. 
.PP
Definition at line 310 of file ValOrErr\&.hpp\&.
.PP
.nf
311     {
312         from_other(std::move(r));
313         return *this;
314     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<template< typename\&.\&.\&. > class variant2, template< class > class in_place_type_t2, class Ret_t2 , class \&.\&.\&. Tps> \fBValOrErr_t\fP& \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::operator= (\fBValOrErr_t\fP< variant2, in_place_type_t2, Ret_t2, Tps\&.\&.\&. > && r)\fC [inline]\fP"
Would only cp/mv the exceptions of type Type held by r only if Type is also in Ts\&.\&.\&.
.PP
Return value is a bit special here: If return value from r is convertible to Ret, then it will be moved if r contains return value\&. 
.PP
Definition at line 324 of file ValOrErr\&.hpp\&.
.PP
.nf
325     {
326         from_other(std::move(r));
327         return *this;
328     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T , class \&.\&.\&. Args, class  = typename std::enable_if<holds_exp<T>() && std::is_constructible<T, Args\&.\&.\&.>::value>::type> void \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::set_exception (Args &&\&.\&.\&. args)\fC [inline]\fP"
Replace the previous value with exception\&.
.PP
If an exception is contained in this object and it is not handled when this function is called, this would cause the program to terminate\&. 
.PP
Definition at line 338 of file ValOrErr\&.hpp\&.
.PP
.nf
339     {
340         throw_if_hold_exp();
341 
342         is_exception_handled = 0;
343         has_exception = 1;
344         v\&.template emplace<T>(std::forward<Args>(args)\&.\&.\&.);
345     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class \&.\&.\&. Args, class  = typename std::enable_if<std::is_constructible<Ret, Args\&.\&.\&.>::value>::type> void \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::set_return_value (Args &&\&.\&.\&. args)\fC [inline]\fP"
Replace the previous value with return value\&.
.PP
If an exception is contained in this object and it is not handled when this function is called, this would cause the program to terminate\&. 
.PP
Definition at line 355 of file ValOrErr\&.hpp\&.
.PP
.nf
356     {
357         throw_if_hold_exp();
358 
359         has_exception = 0;
360         v\&.template emplace<Ret>(std::forward<Args>(args)\&.\&.\&.);
361     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T > bool \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::has_exception_type () const\fC [inline]\fP, \fC [noexcept]\fP"
Test whether this object contain exception of type T\&. 
.PP
Definition at line 376 of file ValOrErr\&.hpp\&.
.PP
.nf
377     {
378         return variant_nonmem_f_t::template holds_alternative<T>(v);
379     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class F > auto \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::Catch (F && f) \-> \fBValOrErr_t\fP&
    \fC [inline]\fP"
Catch and handle the exception\&.
.PP
\fBPostcondition\fP
.RS 4
has_exception_set() == true, has_exception_handled() == true
.RE
.PP
Example: auto g() -> ValOrErr<void, PageNotFound, std::runtime_error, std::invalid_argument>; void f() { g()\&.Catch([](const std::runtime_error &e) { return; })\&.Catch([](const auto &e) { throw e; }); } 
.PP
Definition at line 398 of file ValOrErr\&.hpp\&.
.PP
.nf
399     {
400        if (has_exception && !is_exception_handled && !v\&.valueless_by_exception())
401             visit([&, this](auto &&e) {
402                 using Exception_t = typename std::decay<decltype(e)>::type;
403 
404                 if constexpr(!std::is_same<Exception_t, monostate>::value && 
405                              !std::is_same<Exception_t, Ret>::value)
406                     if constexpr(std::is_invocable<typename std::decay<F>::type, Exception_t>::value) {
407                         is_exception_handled = 1;
408                         std::invoke(std::forward<F>(f), std::forward<decltype(e)>(e));
409                     }
410             }, v);
411 
412         return *this;
413     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> auto& \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::get_return_value () &\fC [inline]\fP"
Get the return value\&.
.PP
If an exception is contained in this object and it is not handled when this function is called, this would cause the program to terminate\&.
.PP
Example: auto g() -> ValOrErr<std::string, PageNotFound, std::runtime_error, std::invalid_argument>; void f() { auto ret = g(); ret\&.Catch([](const std::runtime_error &e) { return; })\&.Catch([](const auto &e) { throw e; });
.PP
auto &s = ret\&.get_return_value(); std::cout << s << std::endl; } 
.PP
Definition at line 437 of file ValOrErr\&.hpp\&.
.PP
.nf
438     {
439         throw_if_hold_exp();
440         return variant_nonmem_f_t::template get<Ret>(v);
441     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> auto& \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::get_return_value () const &\fC [inline]\fP"
Get the return value\&.
.PP
If an exception is contained in this object and it is not handled when this function is called, this would cause the program to terminate\&. 
.PP
Definition at line 450 of file ValOrErr\&.hpp\&.
.PP
.nf
451     {
452         throw_if_hold_exp();
453         return variant_nonmem_f_t::template get<Ret>(v);
454     }
.fi
.SS "template<template< typename\&.\&.\&. > class variant, template< class > class in_place_type_t, class Ret , class \&.\&.\&. Ts> template<class T  = Ret, class  = typename std::enable_if<!std::is_void<T>::value>::type> \fBValOrErr_t\fP< variant, in_place_type_t, Ret, Ts >::operator T& () &\fC [inline]\fP"
Get the return value\&.
.PP
If an exception is contained in this object and it is not handled when this function is called, this would cause the program to terminate\&. 
.PP
Definition at line 477 of file ValOrErr\&.hpp\&.
.PP
.nf
478     {
479         throw_if_hold_exp();
480         return variant_nonmem_f_t::template get<Ret>(v);
481     }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ValOrErr from the source code\&.
